{
  "obsidian": [
    {
      "name": "fetch",
      "description": "Reads and returns the content of any web page. Returns the content in Markdown format by default, or can return raw HTML if raw=true parameter is set. Supports pagination through maxLength and startIndex parameters.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string"
          },
          "maxLength": {
            "type": "number",
            "description": "Limit response length."
          },
          "raw": {
            "anyOf": [
              {
                "type": "boolean"
              }
            ],
            "description": "Returns raw HTML content if raw=true."
          },
          "startIndex": {
            "type": "number",
            "description": "Supports paginated retrieval of content."
          }
        },
        "required": [
          "url"
        ]
      }
    },
    {
      "name": "get_server_info",
      "description": "Returns basic details about the Obsidian Local REST API and authentication status. This is the only API request that does not require authentication.",
      "inputSchema": {
        "type": "object",
        "additionalProperties": {}
      }
    },
    {
      "name": "get_active_file",
      "description": "Returns the content of the currently active file in Obsidian. Can return either markdown content or a JSON representation including parsed tags and frontmatter.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "format": {
            "anyOf": [
              {
                "const": "json"
              },
              {
                "const": "markdown"
              }
            ]
          }
        }
      }
    },
    {
      "name": "update_active_file",
      "description": "Update the content of the active file open in Obsidian.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "content": {
            "type": "string"
          }
        },
        "required": [
          "content"
        ]
      }
    },
    {
      "name": "append_to_active_file",
      "description": "Append content to the end of the currently-open note.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "content": {
            "type": "string"
          }
        },
        "required": [
          "content"
        ]
      }
    },
    {
      "name": "patch_active_file",
      "description": "Insert or modify content in the currently-open note relative to a heading, block reference, or frontmatter field.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "content": {
            "type": "string",
            "description": "The actual content to insert, append, or use as replacement"
          },
          "operation": {
            "anyOf": [
              {
                "const": "append",
                "description": "Specifies how to modify the content: append (add after), prepend (add before), or replace existing content"
              },
              {
                "const": "prepend",
                "description": "Specifies how to modify the content: append (add after), prepend (add before), or replace existing content"
              },
              {
                "const": "replace",
                "description": "Specifies how to modify the content: append (add after), prepend (add before), or replace existing content"
              }
            ],
            "description": "Specifies how to modify the content: append (add after), prepend (add before), or replace existing content"
          },
          "target": {
            "type": "string",
            "description": "The identifier - either heading path (e.g. 'Heading 1::Subheading 1:1'), block reference ID, or frontmatter field name"
          },
          "targetType": {
            "anyOf": [
              {
                "const": "block",
                "description": "Identifies what to modify: a section under a heading, a referenced block, or a frontmatter field"
              },
              {
                "const": "frontmatter",
                "description": "Identifies what to modify: a section under a heading, a referenced block, or a frontmatter field"
              },
              {
                "const": "heading",
                "description": "Identifies what to modify: a section under a heading, a referenced block, or a frontmatter field"
              }
            ],
            "description": "Identifies what to modify: a section under a heading, a referenced block, or a frontmatter field"
          },
          "contentType": {
            "anyOf": [
              {
                "const": "application/json",
                "description": "Format of the content - use application/json for structured data like table rows or frontmatter values"
              },
              {
                "const": "text/markdown",
                "description": "Format of the content - use application/json for structured data like table rows or frontmatter values"
              }
            ],
            "description": "Format of the content - use application/json for structured data like table rows or frontmatter values"
          },
          "targetDelimiter": {
            "type": "string",
            "description": "The separator used in heading paths to indicate nesting (default '::')"
          },
          "trimTargetWhitespace": {
            "anyOf": [
              {
                "type": "boolean"
              }
            ],
            "description": "Whether to remove whitespace from target identifier before matching (default: false)"
          }
        },
        "required": [
          "content",
          "operation",
          "target",
          "targetType"
        ]
      }
    },
    {
      "name": "delete_active_file",
      "description": "Delete the currently-active file in Obsidian.",
      "inputSchema": {
        "type": "object",
        "additionalProperties": {}
      }
    },
    {
      "name": "show_file_in_obsidian",
      "description": "Open a document in the Obsidian UI. Creates a new document if it doesn't exist. Returns a confirmation if the file was opened successfully.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "filename": {
            "type": "string"
          },
          "newLeaf": {
            "anyOf": [
              {
                "type": "boolean"
              }
            ]
          }
        },
        "required": [
          "filename"
        ]
      }
    },
    {
      "name": "search_vault",
      "description": "Search for documents matching a specified query using either Dataview DQL or JsonLogic.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "query": {
            "type": "string"
          },
          "queryType": {
            "anyOf": [
              {
                "const": "dataview"
              },
              {
                "const": "jsonlogic"
              }
            ]
          }
        },
        "required": [
          "query",
          "queryType"
        ]
      }
    },
    {
      "name": "search_vault_simple",
      "description": "Search for documents matching a text query.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "query": {
            "type": "string"
          },
          "contextLength": {
            "type": "number"
          }
        },
        "required": [
          "query"
        ]
      }
    },
    {
      "name": "list_vault_files",
      "description": "List files in the root directory or a specified subdirectory of your vault.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "directory": {
            "type": "string"
          }
        }
      }
    },
    {
      "name": "get_vault_file",
      "description": "Get the content of a file from your vault.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "filename": {
            "type": "string"
          },
          "format": {
            "anyOf": [
              {
                "const": "json"
              },
              {
                "const": "markdown"
              }
            ]
          }
        },
        "required": [
          "filename"
        ]
      }
    },
    {
      "name": "create_vault_file",
      "description": "Create a new file in your vault or update an existing one.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "content": {
            "type": "string"
          },
          "filename": {
            "type": "string"
          }
        },
        "required": [
          "content",
          "filename"
        ]
      }
    },
    {
      "name": "append_to_vault_file",
      "description": "Append content to a new or existing file.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "content": {
            "type": "string"
          },
          "filename": {
            "type": "string"
          }
        },
        "required": [
          "content",
          "filename"
        ]
      }
    },
    {
      "name": "patch_vault_file",
      "description": "Insert or modify content in a file relative to a heading, block reference, or frontmatter field.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "content": {
            "type": "string",
            "description": "The actual content to insert, append, or use as replacement"
          },
          "filename": {
            "type": "string"
          },
          "operation": {
            "anyOf": [
              {
                "const": "append",
                "description": "Specifies how to modify the content: append (add after), prepend (add before), or replace existing content"
              },
              {
                "const": "prepend",
                "description": "Specifies how to modify the content: append (add after), prepend (add before), or replace existing content"
              },
              {
                "const": "replace",
                "description": "Specifies how to modify the content: append (add after), prepend (add before), or replace existing content"
              }
            ],
            "description": "Specifies how to modify the content: append (add after), prepend (add before), or replace existing content"
          },
          "target": {
            "type": "string",
            "description": "The identifier - either heading path (e.g. 'Heading 1::Subheading 1:1'), block reference ID, or frontmatter field name"
          },
          "targetType": {
            "anyOf": [
              {
                "const": "block",
                "description": "Identifies what to modify: a section under a heading, a referenced block, or a frontmatter field"
              },
              {
                "const": "frontmatter",
                "description": "Identifies what to modify: a section under a heading, a referenced block, or a frontmatter field"
              },
              {
                "const": "heading",
                "description": "Identifies what to modify: a section under a heading, a referenced block, or a frontmatter field"
              }
            ],
            "description": "Identifies what to modify: a section under a heading, a referenced block, or a frontmatter field"
          },
          "contentType": {
            "anyOf": [
              {
                "const": "application/json",
                "description": "Format of the content - use application/json for structured data like table rows or frontmatter values"
              },
              {
                "const": "text/markdown",
                "description": "Format of the content - use application/json for structured data like table rows or frontmatter values"
              }
            ],
            "description": "Format of the content - use application/json for structured data like table rows or frontmatter values"
          },
          "targetDelimiter": {
            "type": "string",
            "description": "The separator used in heading paths to indicate nesting (default '::')"
          },
          "trimTargetWhitespace": {
            "anyOf": [
              {
                "type": "boolean"
              }
            ],
            "description": "Whether to remove whitespace from target identifier before matching (default: false)"
          }
        },
        "required": [
          "content",
          "filename",
          "operation",
          "target",
          "targetType"
        ]
      }
    },
    {
      "name": "delete_vault_file",
      "description": "Delete a file from your vault.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "filename": {
            "type": "string"
          }
        },
        "required": [
          "filename"
        ]
      }
    },
    {
      "name": "search_vault_smart",
      "description": "Search for documents semantically matching a text string.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "query": {
            "type": "string",
            "description": "A search phrase for semantic search",
            "minLength": 1
          },
          "filter": {
            "type": "object",
            "properties": {
              "excludeFolders": {
                "type": "array",
                "description": "An array of folder names to exclude. For example, [\"Private\", \"Archive\"]",
                "items": {
                  "type": "string"
                }
              },
              "folders": {
                "type": "array",
                "description": "An array of folder names to include. For example, [\"Public\", \"Work\"]",
                "items": {
                  "type": "string"
                }
              },
              "limit": {
                "type": "number",
                "description": "The maximum number of results to return",
                "exclusiveMinimum": 0
              }
            }
          }
        },
        "required": [
          "query"
        ]
      }
    },
    {
      "name": "execute_template",
      "description": "Execute a Templater template with the given arguments",
      "inputSchema": {
        "type": "object",
        "properties": {
          "arguments": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "name": {
            "type": "string",
            "description": "The full vault path to the template file"
          },
          "createFile": {
            "anyOf": [
              {
                "const": "false"
              },
              {
                "const": "true"
              }
            ]
          },
          "targetPath": {
            "type": "string",
            "description": "Path to save the file; required if createFile is true"
          }
        },
        "required": [
          "arguments",
          "name"
        ]
      }
    }
  ],
  "context7": [
    {
      "name": "resolve-library-id",
      "description": "Resolves a package/product name to a Context7-compatible library ID and returns a list of matching libraries.\n\nYou MUST call this function before 'get-library-docs' to obtain a valid Context7-compatible library ID UNLESS the user explicitly provides a library ID in the format '/org/project' or '/org/project/version' in their query.\n\nSelection Process:\n1. Analyze the query to understand what library/package the user is looking for\n2. Return the most relevant match based on:\n- Name similarity to the query (exact matches prioritized)\n- Description relevance to the query's intent\n- Documentation coverage (prioritize libraries with higher Code Snippet counts)\n- Trust score (consider libraries with scores of 7-10 more authoritative)\n\nResponse Format:\n- Return the selected library ID in a clearly marked section\n- Provide a brief explanation for why this library was chosen\n- If multiple good matches exist, acknowledge this but proceed with the most relevant one\n- If no good matches exist, clearly state this and suggest query refinements\n\nFor ambiguous queries, request clarification before proceeding with a best-guess match.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "libraryName": {
            "type": "string",
            "description": "Library name to search for and retrieve a Context7-compatible library ID."
          }
        },
        "required": [
          "libraryName"
        ],
        "additionalProperties": false,
        "$schema": "http://json-schema.org/draft-07/schema#"
      }
    },
    {
      "name": "get-library-docs",
      "description": "Fetches up-to-date documentation for a library. You must call 'resolve-library-id' first to obtain the exact Context7-compatible library ID required to use this tool, UNLESS the user explicitly provides a library ID in the format '/org/project' or '/org/project/version' in their query.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "context7CompatibleLibraryID": {
            "type": "string",
            "description": "Exact Context7-compatible library ID (e.g., '/mongodb/docs', '/vercel/next.js', '/supabase/supabase', '/vercel/next.js/v14.3.0-canary.87') retrieved from 'resolve-library-id' or directly from user query in the format '/org/project' or '/org/project/version'."
          },
          "topic": {
            "type": "string",
            "description": "Topic to focus documentation on (e.g., 'hooks', 'routing')."
          },
          "tokens": {
            "type": "number",
            "description": "Maximum number of tokens of documentation to retrieve (default: 10000). Higher values provide more context but consume more tokens."
          }
        },
        "required": [
          "context7CompatibleLibraryID"
        ],
        "additionalProperties": false,
        "$schema": "http://json-schema.org/draft-07/schema#"
      }
    }
  ],
  "blender": [
    {
      "name": "get_scene_info",
      "description": "Get detailed information about the current Blender scene",
      "inputSchema": {
        "type": "object",
        "properties": {},
        "title": "get_scene_infoArguments"
      }
    },
    {
      "name": "get_object_info",
      "description": "\nGet detailed information about a specific object in the Blender scene.\n\nParameters:\n- object_name: The name of the object to get information about\n",
      "inputSchema": {
        "type": "object",
        "properties": {
          "object_name": {
            "title": "Object Name",
            "type": "string"
          }
        },
        "required": [
          "object_name"
        ],
        "title": "get_object_infoArguments"
      }
    },
    {
      "name": "get_viewport_screenshot",
      "description": "\nCapture a screenshot of the current Blender 3D viewport.\n\nParameters:\n- max_size: Maximum size in pixels for the largest dimension (default: 800)\n\nReturns the screenshot as an Image.\n",
      "inputSchema": {
        "type": "object",
        "properties": {
          "max_size": {
            "default": 800,
            "title": "Max Size",
            "type": "integer"
          }
        },
        "title": "get_viewport_screenshotArguments"
      }
    },
    {
      "name": "execute_blender_code",
      "description": "\nExecute arbitrary Python code in Blender. Make sure to do it step-by-step by breaking it into smaller chunks.\n\nParameters:\n- code: The Python code to execute\n",
      "inputSchema": {
        "type": "object",
        "properties": {
          "code": {
            "title": "Code",
            "type": "string"
          }
        },
        "required": [
          "code"
        ],
        "title": "execute_blender_codeArguments"
      }
    },
    {
      "name": "get_polyhaven_categories",
      "description": "\nGet a list of categories for a specific asset type on Polyhaven.\n\nParameters:\n- asset_type: The type of asset to get categories for (hdris, textures, models, all)\n",
      "inputSchema": {
        "type": "object",
        "properties": {
          "asset_type": {
            "default": "hdris",
            "title": "Asset Type",
            "type": "string"
          }
        },
        "title": "get_polyhaven_categoriesArguments"
      }
    },
    {
      "name": "search_polyhaven_assets",
      "description": "\nSearch for assets on Polyhaven with optional filtering.\n\nParameters:\n- asset_type: Type of assets to search for (hdris, textures, models, all)\n- categories: Optional comma-separated list of categories to filter by\n\nReturns a list of matching assets with basic information.\n",
      "inputSchema": {
        "type": "object",
        "properties": {
          "asset_type": {
            "default": "all",
            "title": "Asset Type",
            "type": "string"
          },
          "categories": {
            "default": null,
            "title": "Categories",
            "type": "string"
          }
        },
        "title": "search_polyhaven_assetsArguments"
      }
    },
    {
      "name": "download_polyhaven_asset",
      "description": "\nDownload and import a Polyhaven asset into Blender.\n\nParameters:\n- asset_id: The ID of the asset to download\n- asset_type: The type of asset (hdris, textures, models)\n- resolution: The resolution to download (e.g., 1k, 2k, 4k)\n- file_format: Optional file format (e.g., hdr, exr for HDRIs; jpg, png for textures; gltf, fbx for models)\n\nReturns a message indicating success or failure.\n",
      "inputSchema": {
        "type": "object",
        "properties": {
          "asset_id": {
            "title": "Asset Id",
            "type": "string"
          },
          "asset_type": {
            "title": "Asset Type",
            "type": "string"
          },
          "resolution": {
            "default": "1k",
            "title": "Resolution",
            "type": "string"
          },
          "file_format": {
            "default": null,
            "title": "File Format",
            "type": "string"
          }
        },
        "required": [
          "asset_id",
          "asset_type"
        ],
        "title": "download_polyhaven_assetArguments"
      }
    },
    {
      "name": "set_texture",
      "description": "\nApply a previously downloaded Polyhaven texture to an object.\n\nParameters:\n- object_name: Name of the object to apply the texture to\n- texture_id: ID of the Polyhaven texture to apply (must be downloaded first)\n\nReturns a message indicating success or failure.\n",
      "inputSchema": {
        "type": "object",
        "properties": {
          "object_name": {
            "title": "Object Name",
            "type": "string"
          },
          "texture_id": {
            "title": "Texture Id",
            "type": "string"
          }
        },
        "required": [
          "object_name",
          "texture_id"
        ],
        "title": "set_textureArguments"
      }
    },
    {
      "name": "get_polyhaven_status",
      "description": "\nCheck if PolyHaven integration is enabled in Blender.\nReturns a message indicating whether PolyHaven features are available.\n",
      "inputSchema": {
        "type": "object",
        "properties": {},
        "title": "get_polyhaven_statusArguments"
      }
    },
    {
      "name": "get_hyper3d_status",
      "description": "\nCheck if Hyper3D Rodin integration is enabled in Blender.\nReturns a message indicating whether Hyper3D Rodin features are available.\n\nDon't emphasize the key type in the returned message, but sliently remember it. \n",
      "inputSchema": {
        "type": "object",
        "properties": {},
        "title": "get_hyper3d_statusArguments"
      }
    },
    {
      "name": "get_sketchfab_status",
      "description": "\nCheck if Sketchfab integration is enabled in Blender.\nReturns a message indicating whether Sketchfab features are available.\n",
      "inputSchema": {
        "type": "object",
        "properties": {},
        "title": "get_sketchfab_statusArguments"
      }
    },
    {
      "name": "search_sketchfab_models",
      "description": "\nSearch for models on Sketchfab with optional filtering.\n\nParameters:\n- query: Text to search for\n- categories: Optional comma-separated list of categories\n- count: Maximum number of results to return (default 20)\n- downloadable: Whether to include only downloadable models (default True)\n\nReturns a formatted list of matching models.\n",
      "inputSchema": {
        "type": "object",
        "properties": {
          "query": {
            "title": "Query",
            "type": "string"
          },
          "categories": {
            "default": null,
            "title": "Categories",
            "type": "string"
          },
          "count": {
            "default": 20,
            "title": "Count",
            "type": "integer"
          },
          "downloadable": {
            "default": true,
            "title": "Downloadable",
            "type": "boolean"
          }
        },
        "required": [
          "query"
        ],
        "title": "search_sketchfab_modelsArguments"
      }
    },
    {
      "name": "download_sketchfab_model",
      "description": "\nDownload and import a Sketchfab model by its UID.\n\nParameters:\n- uid: The unique identifier of the Sketchfab model\n\nReturns a message indicating success or failure.\nThe model must be downloadable and you must have proper access rights.\n",
      "inputSchema": {
        "type": "object",
        "properties": {
          "uid": {
            "title": "Uid",
            "type": "string"
          }
        },
        "required": [
          "uid"
        ],
        "title": "download_sketchfab_modelArguments"
      }
    },
    {
      "name": "generate_hyper3d_model_via_text",
      "description": "\nGenerate 3D asset using Hyper3D by giving description of the desired asset, and import the asset into Blender.\nThe 3D asset has built-in materials.\nThe generated model has a normalized size, so re-scaling after generation can be useful.\n\nParameters:\n- text_prompt: A short description of the desired model in **English**.\n- bbox_condition: Optional. If given, it has to be a list of floats of length 3. Controls the ratio between [Length, Width, Height] of the model.\n\nReturns a message indicating success or failure.\n",
      "inputSchema": {
        "type": "object",
        "properties": {
          "text_prompt": {
            "title": "Text Prompt",
            "type": "string"
          },
          "bbox_condition": {
            "default": null,
            "items": {
              "type": "number"
            },
            "title": "Bbox Condition",
            "type": "array"
          }
        },
        "required": [
          "text_prompt"
        ],
        "title": "generate_hyper3d_model_via_textArguments"
      }
    },
    {
      "name": "generate_hyper3d_model_via_images",
      "description": "\nGenerate 3D asset using Hyper3D by giving images of the wanted asset, and import the generated asset into Blender.\nThe 3D asset has built-in materials.\nThe generated model has a normalized size, so re-scaling after generation can be useful.\n\nParameters:\n- input_image_paths: The **absolute** paths of input images. Even if only one image is provided, wrap it into a list. Required if Hyper3D Rodin in MAIN_SITE mode.\n- input_image_urls: The URLs of input images. Even if only one image is provided, wrap it into a list. Required if Hyper3D Rodin in FAL_AI mode.\n- bbox_condition: Optional. If given, it has to be a list of ints of length 3. Controls the ratio between [Length, Width, Height] of the model.\n\nOnly one of {input_image_paths, input_image_urls} should be given at a time, depending on the Hyper3D Rodin's current mode.\nReturns a message indicating success or failure.\n",
      "inputSchema": {
        "type": "object",
        "properties": {
          "input_image_paths": {
            "default": null,
            "items": {
              "type": "string"
            },
            "title": "Input Image Paths",
            "type": "array"
          },
          "input_image_urls": {
            "default": null,
            "items": {
              "type": "string"
            },
            "title": "Input Image Urls",
            "type": "array"
          },
          "bbox_condition": {
            "default": null,
            "items": {
              "type": "number"
            },
            "title": "Bbox Condition",
            "type": "array"
          }
        },
        "title": "generate_hyper3d_model_via_imagesArguments"
      }
    },
    {
      "name": "poll_rodin_job_status",
      "description": "\nCheck if the Hyper3D Rodin generation task is completed.\n\nFor Hyper3D Rodin mode MAIN_SITE:\n    Parameters:\n    - subscription_key: The subscription_key given in the generate model step.\n\n    Returns a list of status. The task is done if all status are \"Done\".\n    If \"Failed\" showed up, the generating process failed.\n    This is a polling API, so only proceed if the status are finally determined (\"Done\" or \"Canceled\").\n\nFor Hyper3D Rodin mode FAL_AI:\n    Parameters:\n    - request_id: The request_id given in the generate model step.\n\n    Returns the generation task status. The task is done if status is \"COMPLETED\".\n    The task is in progress if status is \"IN_PROGRESS\".\n    If status other than \"COMPLETED\", \"IN_PROGRESS\", \"IN_QUEUE\" showed up, the generating process might be failed.\n    This is a polling API, so only proceed if the status are finally determined (\"COMPLETED\" or some failed state).\n",
      "inputSchema": {
        "type": "object",
        "properties": {
          "subscription_key": {
            "default": null,
            "title": "Subscription Key",
            "type": "string"
          },
          "request_id": {
            "default": null,
            "title": "Request Id",
            "type": "string"
          }
        },
        "title": "poll_rodin_job_statusArguments"
      }
    },
    {
      "name": "import_generated_asset",
      "description": "\nImport the asset generated by Hyper3D Rodin after the generation task is completed.\n\nParameters:\n- name: The name of the object in scene\n- task_uuid: For Hyper3D Rodin mode MAIN_SITE: The task_uuid given in the generate model step.\n- request_id: For Hyper3D Rodin mode FAL_AI: The request_id given in the generate model step.\n\nOnly give one of {task_uuid, request_id} based on the Hyper3D Rodin Mode!\nReturn if the asset has been imported successfully.\n",
      "inputSchema": {
        "type": "object",
        "properties": {
          "name": {
            "title": "Name",
            "type": "string"
          },
          "task_uuid": {
            "default": null,
            "title": "Task Uuid",
            "type": "string"
          },
          "request_id": {
            "default": null,
            "title": "Request Id",
            "type": "string"
          }
        },
        "required": [
          "name"
        ],
        "title": "import_generated_assetArguments"
      }
    }
  ],
  "html-to-design": [
    {
      "name": "import-url",
      "description": "In the context of Figma and its canvas, using html.to.design. Import the given url into the current canvas, returns the imported node",
      "inputSchema": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string",
            "description": "The URL of the webpage to import"
          },
          "intoNodeId": {
            "type": "string",
            "description": "The node to replace with the imported content, USE ONLY if user requested to replace a node (which includes amending a previously imported content that resulted in a node)"
          },
          "viewport": {
            "type": "number",
            "description": "The viewport width (in pixels) to use for rendering the url"
          },
          "theme": {
            "type": "string",
            "enum": [
              "default",
              "light",
              "dark"
            ]
          },
          "locale": {
            "type": "string",
            "description": "The locale to use for the imported content, like \"en-US\" (default), \"fr-FR\", etc. If country-specific import is requested, try to use a country-specific url, e.g. changing the domain or adding a locale parameter to the url if appropriate"
          }
        },
        "required": [
          "url"
        ],
        "additionalProperties": false,
        "$schema": "http://json-schema.org/draft-07/schema#"
      }
    },
    {
      "name": "import-html",
      "description": "In the context of Figma and its canvas, using html.to.design. Import the given HTML into the current canvas, returns the imported node. It is best to use only Google Fonts as those are available in Figma while others are not necessarily available. If importing a page, provide <html> and <body>, but otherwise just provide the HTML of the component (eg not <html> and <body> elements).",
      "inputSchema": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the imported content"
          },
          "html": {
            "type": "string",
            "description": "The HTML content to import. No use for any comment, minimize HTML/CSS size. If the component is not a page, then just provide the HTML of the component (eg not <html> and <body> elements)"
          },
          "intoNodeId": {
            "type": "string",
            "description": "The node to replace with the imported content, USE ONLY if user requested to replace a node (which includes amending a previously imported content that resulted in a node)"
          }
        },
        "required": [
          "name",
          "html"
        ],
        "additionalProperties": false,
        "$schema": "http://json-schema.org/draft-07/schema#"
      }
    }
  ],
  "line-bot": [
    {
      "name": "push_text_message",
      "description": "Push a simple text message to a user via LINE. Use this for sending plain text messages without formatting.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "userId": {
            "type": "string",
            "default": "U8ba19f9deee77ce7bdeb117d2a2e4514",
            "description": "The user ID to receive a message. Defaults to DESTINATION_USER_ID."
          },
          "message": {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "const": "text",
                "default": "text"
              },
              "text": {
                "type": "string",
                "maxLength": 5000,
                "description": "The plain text content to send to the user."
              }
            },
            "required": [
              "text"
            ],
            "additionalProperties": false
          }
        },
        "required": [
          "message"
        ],
        "additionalProperties": false,
        "$schema": "http://json-schema.org/draft-07/schema#"
      }
    },
    {
      "name": "push_flex_message",
      "description": "Push a highly customizable flex message to a user via LINE. Supports both bubble (single container) and carousel (multiple swipeable bubbles) layouts.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "userId": {
            "type": "string",
            "default": "U8ba19f9deee77ce7bdeb117d2a2e4514",
            "description": "The user ID to receive a message. Defaults to DESTINATION_USER_ID."
          },
          "message": {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "const": "flex",
                "default": "flex"
              },
              "altText": {
                "type": "string",
                "description": "Alternative text shown when flex message cannot be displayed."
              },
              "contents": {
                "type": "object",
                "properties": {
                  "type": {
                    "type": "string",
                    "enum": [
                      "bubble",
                      "carousel"
                    ],
                    "description": "Type of the container. 'bubble' for single container, 'carousel' for multiple swipeable bubbles."
                  }
                },
                "required": [
                  "type"
                ],
                "additionalProperties": true,
                "description": "Flexible container structure following LINE Flex Message format. For 'bubble' type, can include header, hero, body, footer, and styles sections. For 'carousel' type, includes an array of bubble containers in the 'contents' property."
              }
            },
            "required": [
              "altText",
              "contents"
            ],
            "additionalProperties": false
          }
        },
        "required": [
          "message"
        ],
        "additionalProperties": false,
        "$schema": "http://json-schema.org/draft-07/schema#"
      }
    },
    {
      "name": "broadcast_text_message",
      "description": "Broadcast a simple text message via LINE to all users who have followed your LINE Official Account. Use this for sending plain text messages without formatting. Please be aware that this message will be sent to all users.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "message": {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "const": "text",
                "default": "text"
              },
              "text": {
                "type": "string",
                "maxLength": 5000,
                "description": "The plain text content to send to the user."
              }
            },
            "required": [
              "text"
            ],
            "additionalProperties": false
          }
        },
        "required": [
          "message"
        ],
        "additionalProperties": false,
        "$schema": "http://json-schema.org/draft-07/schema#"
      }
    },
    {
      "name": "broadcast_flex_message",
      "description": "Broadcast a highly customizable flex message via LINE to all users who have added your LINE Official Account. Supports both bubble (single container) and carousel (multiple swipeable bubbles) layouts. Please be aware that this message will be sent to all users.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "message": {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "const": "flex",
                "default": "flex"
              },
              "altText": {
                "type": "string",
                "description": "Alternative text shown when flex message cannot be displayed."
              },
              "contents": {
                "type": "object",
                "properties": {
                  "type": {
                    "type": "string",
                    "enum": [
                      "bubble",
                      "carousel"
                    ],
                    "description": "Type of the container. 'bubble' for single container, 'carousel' for multiple swipeable bubbles."
                  }
                },
                "required": [
                  "type"
                ],
                "additionalProperties": true,
                "description": "Flexible container structure following LINE Flex Message format. For 'bubble' type, can include header, hero, body, footer, and styles sections. For 'carousel' type, includes an array of bubble containers in the 'contents' property."
              }
            },
            "required": [
              "altText",
              "contents"
            ],
            "additionalProperties": false
          }
        },
        "required": [
          "message"
        ],
        "additionalProperties": false,
        "$schema": "http://json-schema.org/draft-07/schema#"
      }
    },
    {
      "name": "get_profile",
      "description": "Get detailed profile information of a LINE user including display name, profile picture URL, status message and language.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "userId": {
            "type": "string",
            "default": "U8ba19f9deee77ce7bdeb117d2a2e4514",
            "description": "The user ID to receive a message. Defaults to DESTINATION_USER_ID."
          }
        },
        "additionalProperties": false,
        "$schema": "http://json-schema.org/draft-07/schema#"
      }
    },
    {
      "name": "get_message_quota",
      "description": "Get the message quota and consumption of the LINE Official Account. This shows the monthly message limit and current usage.",
      "inputSchema": {
        "type": "object",
        "properties": {},
        "additionalProperties": false,
        "$schema": "http://json-schema.org/draft-07/schema#"
      }
    }
  ]
}